# GLOSON     :pray:希望人没事

🤣不知道是否高效但应该不高效的超简陋JSON框架(for golang)🙂

### 实现了

- ##### 简单JSON的反序列化:blush:

  ```go
  	s := "{\n\"name\":\"网站\",\n\"num\":3,\n\"sites\":[1,2,3]\n}"
  	type AutoGenerated struct {
  		Name  string  `json:"name"`
  		Num   int     `json:"num"`
  		Sites []int64 `json:"sites"`
  	}
  	a := &AutoGenerated{}
  	err := gloson.Bind(s, a)
  	if err == nil {
  		fmt.Printf("%+v", a)
  	}
  ```

  输出结果为

  ```
  === RUN   Test2
  &{Name:"网站" Num:3 Sites:[1 2 3]}--- PASS: Test2 (0.00s)
  PASS
  ```

- ##### 复杂JSON的反序列化（嵌套）:alien:

  ```go
  	s := "{\n\"GlossDef\": {\n\"para\": \"as DocBook.\",\n\"GlossSeeAlso\":	{par:\"pppapp\",glo:1}\n},\n\"GlossSee\": \"markup\"\n}"
  	type GlossSeeAlso struct {
  		Par string `json:"par"`
  		Glo int    `json:"glo"`
  	}
  	type GlossDef struct {
  		Para         string       `json:"para"`
  		GlossSeeAlso GlossSeeAlso `json:"GlossSeeAlso"`
  	}
  	type AutoGenerated struct {
  		GlossDef GlossDef `json:"GlossDef"`
  		GlossSee string   `json:"GlossSee"`
  	}
  	a := &AutoGenerated{}
  	err := gloson.Bind(s, a)
  	if err == nil {
  		fmt.Printf("%+v", a)
  	}
  ```

  输出结果为

  ```
  === RUN   TestBind
  &{GlossDef:{Para:"asDocBook." GlossSeeAlso:{Par:"pppapp" Glo:1}} GlossSee:"markup"}--- PASS: TestBind (0.00s)
  PASS
  ```

- ##### 简单JSON的序列化:+1:

  ```go
  	type AutoGenerated struct {
  		Name bool      `json:"name"`
  		Num  []float64 `json:"num"`
  		Test []string  `json:"test"`
  	}
  	a := &AutoGenerated{
  		Name: false,
  		Num:  []float64{123120.123, 4.2317823019, 6, 8273},
  		Test: []string{"", "~!!@##$%%^&^&*(){}:}|", "asiojdoa"},
  	}
  	s, _ := gloson.Marshall(a)
  	fmt.Println(s)
  ```

  输出结果为

  ```
  === RUN   Test5
  {
      "name":false,
      "num":[123120.123, 4.2317823019, 6, 8273],
      "test":["", "~!!@##$%%^&^&*(){}:}|", "asiojdoa"]
  }
  --- PASS: Test5 (0.00s)
  PASS
  ```



### :clap:实现过程

#### 序列化:v:

- 通过反射（reflect），可以获得传入结构体的信息，最重要的是`reflect.TypeOf(）`和`reflect.ValueOf(）`

  这两个函数：

  ```go
  func (glom *GlosonMa) ViewItem() error {
  	ObjTyp := reflect.TypeOf(glom.Object).Elem()
  	fNum := ObjTyp.NumField()
  	glom.ItemNum = fNum
  	tagMap := make(map[int]Item)
  	for i := 0; i < fNum; i++ {
  		key := ObjTyp.Field(i).Tag.Get("json")
  		if key == "" {
  			return errors.New("void tag")
  		}
  		t := reflect.ValueOf(glom.Object)
  		if t.Kind() == reflect.Ptr {
  			t = t.Elem()
  		}
  		if t.Field(i).Kind() == reflect.Struct {
  			glom.Nesting = append(glom.Nesting, i)
  		}
  		value := t.Field(i).Interface()
  		tagMap[i] = Item{
  			Name:  key,
  			Value: value,
  		}
  	}
  	glom.TagMap = tagMap
  	return nil
  }
  ```

  - `ObjTyp := reflect.TypeOf(glom.Object).Elem()`

  - `fNum := ObjTyp.NumField()`获取了传入结构体的字段数，便于后续的遍历