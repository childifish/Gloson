# GLOSON     :pray:希望人没事

🤣不知道是否高效但应该不高效的超简陋JSON框架(for golang)🙂

（dbq我不该觉得jso框架简单）

### 实现了

- ##### 简单JSON的反序列化:blush:

  ```go
  	s := "{\n\"name\":\"网站\",\n\"num\":3,\n\"sites\":[1,2,3]\n}"
  	type AutoGenerated struct {
  		Name  string  `json:"name"`
  		Num   int     `json:"num"`
  		Sites []int64 `json:"sites"`
  	}
  	a := &AutoGenerated{}
  	err := gloson.Bind(s, a)
  	if err == nil {
  		fmt.Printf("%+v", a)
  	}
  ```

  输出结果为

  ```
  === RUN   Test2
  &{Name:"网站" Num:3 Sites:[1 2 3]}--- PASS: Test2 (0.00s)
  PASS
  ```

- ##### 复杂JSON的反序列化（嵌套）:alien:

  ```go
  	s := "{\n\"GlossDef\": {\n\"para\": \"as DocBook.\",\n\"GlossSeeAlso\":	{par:\"pppapp\",glo:1}\n},\n\"GlossSee\": \"markup\"\n}"
  	type GlossSeeAlso struct {
  		Par string `json:"par"`
  		Glo int    `json:"glo"`
  	}
  	type GlossDef struct {
  		Para         string       `json:"para"`
  		GlossSeeAlso GlossSeeAlso `json:"GlossSeeAlso"`
  	}
  	type AutoGenerated struct {
  		GlossDef GlossDef `json:"GlossDef"`
  		GlossSee string   `json:"GlossSee"`
  	}
  	a := &AutoGenerated{}
  	err := gloson.Bind(s, a)
  	if err == nil {
  		fmt.Printf("%+v", a)
  	}
  ```

  输出结果为

  ```
  === RUN   TestBind
  &{GlossDef:{Para:"asDocBook." GlossSeeAlso:{Par:"pppapp" Glo:1}} GlossSee:"markup"}--- PASS: TestBind (0.00s)
  PASS
  ```

- ##### 简单JSON的序列化:+1:

  ```go
  	type AutoGenerated struct {
  		Name bool      `json:"name"`
  		Num  []float64 `json:"num"`
  		Test []string  `json:"test"`
  	}
  	a := &AutoGenerated{
  		Name: false,
  		Num:  []float64{123120.123, 4.2317823019, 6, 8273},
  		Test: []string{"", "~!!@##$%%^&^&*(){}:}|", "asiojdoa"},
  	}
  	s, _ := gloson.Marshall(a)
  	fmt.Println(s)
  ```

  输出结果为

  ```
  === RUN   Test5
  {
      "name":false,
      "num":[123120.123, 4.2317823019, 6, 8273],
      "test":["", "~!!@##$%%^&^&*(){}:}|", "asiojdoa"]
  }
  --- PASS: Test5 (0.00s)
  PASS
  ```

- ##### 比较复杂的JSON的序列化:jack_o_lantern:

  ```go
  type GlossDiv struct {
  		Title2    string `json:"title2"`
  		GlossList int    `json:"GlossList"`
  	}
  	type Glossary struct {
  		Title1   string   `json:"title1"`
  		GlossDiv GlossDiv `json:"GlossDiv"`
  		K        string   `json:"k"`
  	}
  	type AutoGenerated struct {
  		B        int      `json:"b"`
  		Glossary Glossary `json:"Glossary"`
  		C        string   `json:"c"`
  	}
  	a := &AutoGenerated{
  		Glossary: Glossary{
  			GlossDiv: GlossDiv{
  				Title2:    "23333",
  				GlossList: 1,
  			},
  			Title1: "11415",
  			K:      "adsasd",
  		},
  		B: 1,
  		C: "123123",
  	}
  	js := gloson.Marshall(a)
  	fmt.Println(js)
  ```

  输出结果为

  ```go
  === RUN   TestMarshall3
  {
      "b":1,
      "Glossary":{
          "title1":"11415",
          "GlossDiv":{
              "title2":"23333",
              "GlossList":1,
          },
          "k":"adsasd",
      },
      "c":"123123",
  }
  --- PASS: TestMarshall3 (0.00s)
  PASS
  ```

### :clap:实现过程

#### 序列化:v:

- 通过反射（reflect），可以让我们解析传入结构体，轻松（并不）地获取结构体的字段数（`.NumField()`），tag（`.Tag.Get("json")`），类型（`.Kind()`）

- 获取这些信息的前提是`reflect.ValueOf()`和`reflect.TypeOf()`其中`reflect.ValueOf()`必须以指针传递

- 获取精确的字段需要`.FieldByIndex()`或者`.Field()`，`.Field()`用int传参，`.FieldByIndex()`用int数组，两者的区别在于，`.FieldByIndex()`能够获取嵌套结构体内的成员，例如：

  ```go
  type GlossDiv struct {
  		Title2    string `json:"title2"`
  		GlossList int    `json:"GlossList"`
  	}
  	type Glossary struct {
  		Title1   string   `json:"title1"`
  		GlossDiv GlossDiv `json:"GlossDiv"`
  	}
  	type AutoGenerated struct {
  		Glossary Glossary `json:"Glossary"`
  		B        int      `json:"b"`
  	}
  ```

  将AutoGenerated作为传入的参数，其中获取第一个成员Glossary需要的`.FieldByIndex([]int{0})`，而Glossary结构体内嵌在AutoGenerated中，Glossary的第一个成员Title1就是`.FieldByIndex([]int{0,0})`,GlossDiv里的GlossList则是`.FieldByIndex([]int{0,1,1})`,以此类推

- 获取了这些信息就可以自由组合了，序列化这个东西..因为是后写的，出的问题不多，而且确实简单，感觉有手就行吧，没什么好说的（加起来也就一百八十行）

- 序列化处理套娃的具体实现都写在代码里了

- 虽说能用但..

  这是自带的json序列化

  ```
  goos: windows
  goarch: amd64
  pkg: gloson/test
  Benchmark2
  Benchmark2-8      857743              1342 ns/op
  PASS
  ```

  这是我写的

  ```
  goos: windows
  goarch: amd64
  pkg: gloson/test
  Benchmark
  Benchmark-8        96774             14159 ns/op
  PASS
  ```

  大概有十倍的差距

- 而相对（绝对）困难的是下面的...

#### 反序列化​​☠

- 这是我写的

  ```
  goos: windows
  goarch: amd64
  pkg: gloson/test
  Benchmark3
  Benchmark3-8       85110             23466 ns/op
  PASS
  ```

  这个是自带的

  ```
  goos: windows
  goarch: amd64
  pkg: gloson/test
  Benchmark3
  Benchmark3-8      923140              1549 ns/op
  PASS
  ```

  大概十五倍

- 为什么有这么大的差距呢