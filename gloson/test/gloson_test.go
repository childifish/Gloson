package test

import (
	"fmt"
	"gloson/gloson"
	"gloson/under"
	"reflect"
	"testing"
)

//递归打印map
func RecursionPrint(input map[string]interface{}) {
	for k, v := range input {
		fmt.Println("key", k, "value", v, "type", reflect.TypeOf(v))
		value := v.(under.JsonKV)
		if value.WithinType == "option" {
			mapIn, ok := value.Within.(map[string]interface{})
			if ok {
				RecursionPrint(mapIn)
			}
		}
	}
	return
}

//简单反序列化--map
func Test(t *testing.T) {
	s := "{\n    \"data\": {\n        \"goods\": null\n    },\n    \"info\": \"success\",\n    \"status\": 200\n}"
	map1, _ := gloson.Map(s)
	fmt.Println(map1)
}

//简单反序列化--struct
func Test2(t *testing.T) {
	s := "{\n\"name\":\"网站\",\n\"num\":3,\n\"sites\":[1,2,3]\n}"
	type AutoGenerated struct {
		Name  string  `json:"name"`
		Num   int     `json:"num"`
		Sites []int64 `json:"sites"`
	}
	a := &AutoGenerated{}
	gloson.Bind(s, a)
	fmt.Println(a)
}

//简单序列化
func Test3(t *testing.T) {
	type AutoGenerated struct {
		Name string `json:"name"`
		Num  int    `json:"num"`
	}
	a := &AutoGenerated{
		Name: "111",
		Num:  123,
	}
	s, _ := gloson.Marshall(a)
	fmt.Println(s)
}

//简单float序列化
func Test4(t *testing.T) {
	type AutoGenerated struct {
		Name bool    `json:"name"`
		Num  float64 `json:"num"`
	}
	a := &AutoGenerated{
		Name: false,
		Num:  123.001,
	}
	s, _ := gloson.Marshall(a)
	fmt.Println(s)
}

//简单数组序列化//带中文和中文字符的会爆炸
func Test5(t *testing.T) {
	type AutoGenerated struct {
		Name bool      `json:"name"`
		Num  []float64 `json:"num"`
		Test []string  `json:"test"`
	}
	a := &AutoGenerated{
		Name: false,
		Num:  []float64{123120.123, 4.2317823019, 6, 8273},
		Test: []string{"", "~!!@##$%%^&^&*(){}:}|", "asiojdoa"},
	}
	s, _ := gloson.Marshall(a)
	fmt.Println(s)
}

//单层套娃
func TestUnmarshall_Bind(t *testing.T) {
	s := "{\n\"GlossDef\": {\n\"para\": \"A meta-markup language, used to create markup languages such as DocBook.\",\n\"GlossSeeAlso\": \"1\"\n},\n\"GlossSee\": \"markup\"\n}"
	type GlossDef struct {
		Para         string `json:"para"`
		GlossSeeAlso string `json:"GlossSeeAlso"`
	}
	type AutoGenerated struct {
		GlossDef GlossDef `json:"GlossDef"`
		GlossSee string   `json:"GlossSee"`
	}
	a := &AutoGenerated{}
	gloson.Bind(s, a)
	fmt.Println(a)

}

//对reflect包的测试
func TestReflect(t *testing.T) {
	//s := "{\n\"GlossDef\": {\n\"para\": \"A meta-markup language, used to create markup languages such as DocBook.\",\n\"GlossSeeAlso\": [\n\"GML\",\n\"XML\"\n]\n},\n\"GlossSee\": \"markup\"\n}"
	type GlossDef struct {
		Para         string   `json:"para"`
		GlossSeeAlso []string `json:"GlossSeeAlso"`
	}
	type AutoGenerated struct {
		GlossDef GlossDef `json:"GlossDef"`
		GlossSee string   `json:"GlossSee"`
	}
	a := &AutoGenerated{}
	va := reflect.ValueOf(a).Elem().Field(1)
	va.Set(reflect.ValueOf("1231231231"))
	fmt.Println("va", va)
	typ := reflect.TypeOf(a).Elem().FieldByIndex([]int{0, 1}).Tag.Get("json")
	fmt.Println("typ", typ)
	va2 := reflect.ValueOf(a).Elem().FieldByIndex([]int{1})
	va2.Set(reflect.ValueOf("wo"))
	fmt.Println(va2)
	//fmt.Println(reflect.TypeOf())

}

//三层结构体套娃 反序列化
func TestBind(t *testing.T) {
	s := "{\n\"GlossDef\": {\n\"para\": \"as DocBook.\",\n\"GlossSeeAlso\": {par:\"pppapp\",glo:1}\n},\n\"GlossSee\": \"markup\"\n}"
	type GlossSeeAlso struct {
		Par string `json:"par"`
		Glo int    `json:"glo"`
	}
	type GlossDef struct {
		Para         string       `json:"para"`
		GlossSeeAlso GlossSeeAlso `json:"GlossSeeAlso"`
	}
	type AutoGenerated struct {
		GlossDef GlossDef `json:"GlossDef"`
		GlossSee string   `json:"GlossSee"`
	}
	a := &AutoGenerated{}
	gloson.Bind(s, a)
	fmt.Println(a)
}

func TestMap(t *testing.T) {
	s := "{\n\"glossary\": {\n\"title\": \"example glossary\",\n\"GlossDiv\": {\n\"titles\": \"S\",\n\"GlossList\": {\n\"GlossEntry\": {\n\"ID\": \"SGML\",\n\"SortAs\": \"SGML\",\n\"GlossTerm\": \"Standard Generalized Markup Language\",\n\"Acronym\": \"SGML\",\n\"Abbrev\": \"ISO 8879:1986\",\n\"GlossDef\": {\n\"para\": \"A meta-markup language, used to create markup languages such as DocBook.\",\n\"GlossSeeAlso\": [\n\"GML\",\n\"XML\"\n]\n},\n\"GlossSee\": \"markup\"\n}\n}\n}\n}\n}"
	ma, _ := gloson.Map(s)
	fmt.Println(ma)
}
